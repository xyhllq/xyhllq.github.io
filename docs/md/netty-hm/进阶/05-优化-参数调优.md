
> 说明：  
> 客户端：  
>  * 通过`.option()`方法配置参数  
> 
> 服务端：
>  * 通过`new ServerBootstrap().option()`，是给`ServerSocketChannel`配置参数
>  * 通过`new ServerBootstrap().childOption()`，是给`SocketChannel`配置参数

## 一、CONNECT_TIMEOUT_MILLIS

### 1、说明

 * 属于`SocketChannel`参数
 * 用于客户端建立连接时，如果在指定毫秒内无法连接，会抛出 `timeout`异常
 * `SO_TIMEOUT`主要用在阻塞IO，阻塞IO中accept、read等都是无限等待的，如果不希望永远阻塞，使用它调整超时时间

### 2、客户端实现

```java
import io.netty.bootstrap.Bootstrap;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelOption;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.nio.NioSocketChannel;
import io.netty.handler.logging.LoggingHandler;
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class TestConnectTimeout {

    public static void main(String[] args) {
        NioEventLoopGroup group = new NioEventLoopGroup();
        try{
            Bootstrap bootstrap = new Bootstrap()
                    .group(group)
                    .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 300)
                    .channel(NioSocketChannel.class)
                    .handler(new LoggingHandler());
            //因为使用 localhost 一直模拟不出来，使用这个地址
            ChannelFuture channelFuture = bootstrap.connect("www.baidu.com", 8080);
            ChannelFuture future = channelFuture.sync();//断点
            future.channel().closeFuture().sync();
        }catch (Exception e){
            e.printStackTrace();
            log.debug("timeout");
        }finally {
            group.shutdownGracefully();
        }
    }
}
```

### 3、控制台输出
```
18:49:14 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xc9d9418e] REGISTERED
18:49:14 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xc9d9418e] CONNECT: www.baidu.com/180.101.49.11:8080
18:49:14 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xc9d9418e] CLOSE
18:49:14 [DEBUG] [main] m.x.n.c.TestConnectTimeout - timeout
18:49:14 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xc9d9418e] UNREGISTERED
io.netty.channel.ConnectTimeoutException: connection timed out: www.baidu.com/180.101.49.11:8080
	at io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe$1.run(AbstractNioChannel.java:263)
	at io.netty.util.concurrent.PromiseTask$RunnableAdapter.call(PromiseTask.java:38)
	at io.netty.util.concurrent.ScheduledFutureTask.run(ScheduledFutureTask.java:127)
	at io.netty.util.concurrent.AbstractEventExecutor.safeExecute(AbstractEventExecutor.java:163)
	at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:416)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:515)
	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918)
	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.lang.Thread.run(Thread.java:748)
```

### 4、源码

> 通过`at io.netty.channel.nio.AbstractNioChannel$AbstractNioUnsafe$1.run(AbstractNioChannel.java:263)`点进去

```java
public abstract class AbstractNioChannel extends AbstractChannel {
    protected abstract class AbstractNioUnsafe extends AbstractUnsafe implements NioUnsafe {
        @Override
        public final void connect(
                final SocketAddress remoteAddress, final SocketAddress localAddress, final ChannelPromise promise) {
            //...
            // 获取超时时间
            int connectTimeoutMillis = config().getConnectTimeoutMillis();
            if (connectTimeoutMillis > 0) {
                //启动一个定时任务
                connectTimeoutFuture = eventLoop().schedule(new Runnable() {
                    @Override
                    public void run() {
                        ChannelPromise connectPromise = AbstractNioChannel.this.connectPromise;
                        //断点---thread模式
                        ConnectTimeoutException cause =
                                new ConnectTimeoutException("connection timed out: " + remoteAddress);
                        //把异常抛出
                        if (connectPromise != null && connectPromise.tryFailure(cause)) {
                            close(voidPromise());
                        }
                    }
                }, connectTimeoutMillis, TimeUnit.MILLISECONDS);
            }
            //...
        }
        //...
    }
}
```




